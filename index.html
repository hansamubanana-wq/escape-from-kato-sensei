<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Âä†Ëó§ÂÖàÁîü„Åã„ÇâÈÄÉ„Åí„ÇçÔºÅUltimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
            position: relative;
        }
        
        #gameCanvas {
            border: 4px solid #4ecca3;
            background: #2d2d44;
            touch-action: none;
            box-shadow: 0 0 30px rgba(78, 204, 163, 0.3);
            border-radius: 8px;
        }
        
        /* ÁîªÈù¢„Ç®„Éï„Çß„ÇØ„ÉàÁî®„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        #screenEffects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
        }
        
        .screen-shake {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-10px, 0); }
            20%, 40%, 60%, 80% { transform: translate(10px, 0); }
        }
        
        .damage-flash {
            animation: damageFlash 0.3s;
        }
        
        @keyframes damageFlash {
            0%, 100% { background: transparent; }
            50% { background: rgba(233, 69, 96, 0.4); }
        }
        
        .vignette {
            box-shadow: inset 0 0 200px rgba(0, 0, 0, 0.8);
            transition: box-shadow 0.5s;
        }
        
        @media (orientation: portrait) {
            #gameCanvas {
                max-width: 100%;
                max-height: 70vh;
            }
        }
        
        @media (orientation: landscape) {
            #gameCanvas {
                max-width: 95vw;
                max-height: 90vh;
                width: auto;
                height: auto;
            }
            
            #gameContainer {
                padding: 5px;
            }
        }
        
        #joystickContainer {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            z-index: 100;
        }
        
        @media (orientation: landscape) {
            #joystickContainer {
                bottom: 20px;
                left: 20px;
                width: 120px;
                height: 120px;
            }
            
            #joystickBase {
                width: 120px !important;
                height: 120px !important;
            }
            
            #joystickStick {
                width: 50px !important;
                height: 50px !important;
            }
        }
        
        #joystickBase {
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(78, 204, 163, 0.3), rgba(78, 204, 163, 0.1));
            border: 4px solid rgba(78, 204, 163, 0.5);
            box-shadow: 0 0 20px rgba(78, 204, 163, 0.3);
        }
        
        #joystickStick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(78, 204, 163, 0.9), rgba(78, 204, 163, 0.6));
            border: 4px solid rgba(78, 204, 163, 1);
            left: 40px;
            top: 40px;
            touch-action: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        #ui {
            position: fixed;
            top: 15px;
            left: 15px;
            color: white;
            font-size: 18px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            padding: 15px 20px;
            border-radius: 12px;
            z-index: 50;
            border: 2px solid rgba(78, 204, 163, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        @media (orientation: landscape) {
            #ui {
                font-size: 16px;
                padding: 10px 15px;
            }
        }
        
        #ui div {
            margin: 5px 0;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #lives {
            font-size: 24px;
        }
        
        #minimap {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 160px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(78, 204, 163, 0.5);
            border-radius: 8px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        @media (orientation: landscape) {
            #minimap {
                width: 140px;
                height: 105px;
            }
        }
        
        #gameOverScreen, #startScreen, #clearScreen, #statsScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.98));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            color: white;
            overflow-y: auto;
        }
        
        #startScreen h1, #gameOverScreen h1, #clearScreen h1, #statsScreen h1 {
            font-size: 36px;
            margin-bottom: 25px;
            text-align: center;
            text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.8);
        }
        
        #startScreen p, #gameOverScreen p, #clearScreen p {
            font-size: 20px;
            margin-bottom: 35px;
            text-align: center;
            padding: 0 20px;
            line-height: 1.6;
        }
        
        @media (orientation: landscape) {
            #startScreen h1, #gameOverScreen h1, #clearScreen h1, #statsScreen h1 {
                font-size: 28px;
                margin-bottom: 15px;
            }
            
            #startScreen p, #gameOverScreen p, #clearScreen p {
                font-size: 16px;
                margin-bottom: 20px;
            }
            
            .btn {
                padding: 12px 30px !important;
                font-size: 18px !important;
            }
        }
        
        .btn {
            padding: 18px 40px;
            font-size: 22px;
            background: linear-gradient(135deg, #e94560, #c73a52);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            touch-action: manipulation;
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.4);
            transition: all 0.3s;
            font-weight: bold;
            margin: 5px;
        }
        
        .btn:active {
            background: linear-gradient(135deg, #c73a52, #a32d42);
            transform: translateY(2px);
            box-shadow: 0 3px 10px rgba(233, 69, 96, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #4ecca3, #45b393);
        }
        
        .btn-secondary:active {
            background: linear-gradient(135deg, #45b393, #3a9d7d);
        }
        
        #clearScreen h1 {
            color: #4ecca3;
            text-shadow: 0 0 20px rgba(78, 204, 163, 0.6);
        }
        
        .hidden {
            display: none !important;
        }
        
        #progressBarContainer {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid rgba(78, 204, 163, 0.3);
            display: none;
            z-index: 100;
        }
        
        @media (orientation: landscape) {
            #progressBarContainer {
                bottom: 20px;
                right: 20px;
                padding: 10px;
            }
            
            #progressBar {
                width: 150px !important;
                height: 20px !important;
            }
            
            #progressLabel {
                font-size: 12px !important;
            }
        }
        
        #progressBarContainer.active {
            display: block;
        }
        
        #progressBar {
            width: 200px;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(78, 204, 163, 0.5);
        }
        
        #progressBarFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ecca3, #45b393);
            transition: width 0.1s;
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.6);
        }
        
        #progressLabel {
            color: #4ecca3;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #difficultySelect {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .difficulty-btn {
            padding: 12px 24px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .difficulty-btn:hover, .difficulty-btn.selected {
            background: rgba(78, 204, 163, 0.3);
            border-color: #4ecca3;
            box-shadow: 0 0 15px rgba(78, 204, 163, 0.4);
        }
        
        #highScores {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            max-width: 400px;
        }
        
        #highScores h3 {
            color: #4ecca3;
            margin-bottom: 10px;
        }
        
        #highScores ol {
            text-align: left;
            padding-left: 25px;
        }
        
        #highScores li {
            margin: 5px 0;
        }
        
        #soundToggle {
            position: fixed;
            top: 15px;
            right: 190px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(78, 204, 163, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 50;
            font-size: 20px;
        }
        
        @media (orientation: landscape) {
            #soundToggle {
                right: 160px;
                padding: 8px 12px;
                font-size: 18px;
            }
        }
        
        #achievements {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            max-width: 500px;
            margin: 20px;
        }
        
        .achievement {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #555;
        }
        
        .achievement.unlocked {
            border-left-color: #4ecca3;
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.3);
        }
        
        .achievement-icon {
            font-size: 30px;
            margin-right: 15px;
        }
        
        .achievement-info h4 {
            margin: 0;
            color: #4ecca3;
        }
        
        .achievement-info p {
            margin: 5px 0 0 0;
            font-size: 14px;
            color: #aaa;
        }
        
        #stats {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            margin: 20px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }
        
        .stat-label {
            color: #4ecca3;
        }
        
        .stat-value {
            font-weight: bold;
        }
        
        #hideButton {
            position: fixed;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.8);
            color: white;
            padding: 12px 24px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            display: none;
            z-index: 100;
            cursor: pointer;
        }
        
        #hideButton.show {
            display: block;
        }
    </style>
</head>
<body>
    <div id="screenEffects"></div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div id="joystickContainer">
        <div id="joystickBase"></div>
        <div id="joystickStick"></div>
    </div>
    
    <div id="ui">
        <div id="lives">‚ù§Ô∏è √ó3</div>
        <div>üìù „Çø„Çπ„ÇØ: <span id="taskCount">0/5</span></div>
        <div>‚è±Ô∏è ÊôÇÈñì: <span id="timer">0:00</span></div>
        <div id="powerupStatus"></div>
        <div id="hidingStatus" style="display:none; color:#e94560;">üö™ Èö†„Çå‰∏≠...</div>
    </div>
    
    <canvas id="minimap"></canvas>
    
    <button id="soundToggle" onclick="toggleSound()">üîä</button>
    <button id="hideButton" onclick="enterLocker()">üö™ Èö†„Çå„Çã (E)</button>
    
    <div id="progressBarContainer">
        <div id="progressLabel">„Çø„Çπ„ÇØÈÄ≤Ë°å‰∏≠...</div>
        <div id="progressBar">
            <div id="progressBarFill"></div>
        </div>
    </div>
    
    <div id="startScreen">
        <h1>üèÉ Âä†Ëó§ÂÖàÁîü„Åã„ÇâÈÄÉ„Åí„ÇçÔºÅ</h1>
        <h2 style="color: #4ecca3;">Ultimate Edition</h2>
        
        <div id="highScores" class="hidden">
            <h3>üèÜ „Éè„Ç§„Çπ„Ç≥„Ç¢</h3>
            <ol id="scoreList"></ol>
        </div>
        
        <p>Êï∞Â≠¶ÊïôÂ∏´„ÅÆÂä†Ëó§ÂÖàÁîü„Åã„ÇâÈÄÉ„Åí„Å™„Åå„Çâ<br>„Çø„Çπ„ÇØ„Çí„ÇØ„É™„Ç¢„Åó„Å¶ËÑ±Âá∫„Åó„Çà„ÅÜÔºÅ</p>
        
        <div id="difficultySelect">
            <button class="difficulty-btn selected" onclick="selectDifficulty('easy')">
                üòä „Ç§„Éº„Ç∏„Éº
            </button>
            <button class="difficulty-btn" onclick="selectDifficulty('normal')">
                üòê „Éé„Éº„Éû„É´
            </button>
            <button class="difficulty-btn" onclick="selectDifficulty('hard')">
                üò± „Éè„Éº„Éâ
            </button>
        </div>
        
        <p style="font-size: 16px;">
            ‚ö° „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„ÇíÈõÜ„ÇÅ„Çà„ÅÜÔºÅ<br>
            üöÄ „Çπ„Éî„Éº„Éâ üëª ÈÄèÊòéÂåñ ‚è∏Ô∏è ÊôÇÈñìÂÅúÊ≠¢<br>
            üö™ „É≠„ÉÉ„Ç´„Éº„Å´Èö†„Çå„Å¶Êïµ„Çí„ÇÑ„ÇäÈÅé„Åî„Åù„ÅÜÔºÅ
        </p>
        
        <button class="btn" onclick="startGame()">„Ç≤„Éº„É†ÈñãÂßã</button>
        <button class="btn btn-secondary" onclick="showStats()">Áµ±Ë®à„ÉªÂÆüÁ∏æ</button>
    </div>
    
    <div id="gameOverScreen" class="hidden">
        <h1>üò± „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h1>
        <p>ÂÖ®„Å¶„ÅÆ„É©„Ç§„Éï„ÇíÂ§±„ÅÑ„Åæ„Åó„Åü...</p>
        <button class="btn" onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶</button>
        <button class="btn btn-secondary" onclick="showStats()">Áµ±Ë®à„ÉªÂÆüÁ∏æ</button>
    </div>
    
    <div id="clearScreen" class="hidden">
        <h1>üéâ ËÑ±Âá∫ÊàêÂäüÔºÅ</h1>
        <p id="clearMessage"></p>
        <p>‚è±Ô∏è „Çø„Ç§„É†: <span id="finalTime"></span></p>
        <div id="newAchievements"></div>
        <button class="btn" onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        <button class="btn btn-secondary" onclick="showStats()">Áµ±Ë®à„ÉªÂÆüÁ∏æ</button>
    </div>
    
    <div id="statsScreen" class="hidden">
        <h1>üìä Áµ±Ë®à„ÉªÂÆüÁ∏æ</h1>
        
        <div id="stats">
            <h3 style="color: #4ecca3; margin-bottom: 15px;">Áµ±Ë®à</h3>
            <div class="stat-item">
                <span class="stat-label">Á∑è„Éó„É¨„Ç§ÊôÇÈñì</span>
                <span class="stat-value" id="totalPlayTime">0ÂàÜ</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Á¥ØË®à„ÇØ„É™„Ç¢ÂõûÊï∞</span>
                <span class="stat-value" id="totalClears">0Âõû</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Á¥ØË®àÊ≠ª‰∫°ÂõûÊï∞</span>
                <span class="stat-value" id="totalDeaths">0Âõû</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">ÊúÄÈÄü„ÇØ„É™„Ç¢„Çø„Ç§„É†</span>
                <span class="stat-value" id="bestTime">--:--</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">„Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÂèñÂæóÊï∞</span>
                <span class="stat-value" id="totalPowerups">0ÂÄã</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Èö†„Çå„ÅüÂõûÊï∞</span>
                <span class="stat-value" id="totalHides">0Âõû</span>
            </div>
        </div>
        
        <div id="achievements">
            <h3 style="color: #4ecca3; margin-bottom: 15px;">ÂÆüÁ∏æ (<span id="achievementCount">0/10</span>)</h3>
            <div id="achievementList"></div>
        </div>
        
        <button class="btn" onclick="closeStats()">Êàª„Çã</button>
        <button class="btn btn-secondary" onclick="resetStats()">Áµ±Ë®à„É™„Çª„ÉÉ„Éà</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        const GAME_WIDTH = 1600;
        const GAME_HEIGHT = 1200;
        const VIEWPORT_WIDTH = 800;
        const VIEWPORT_HEIGHT = 600;
        
        let camera = {x: 0, y: 0};
        
        function resizeCanvas() {
            const isLandscape = window.innerWidth > window.innerHeight;
            
            canvas.width = VIEWPORT_WIDTH;
            canvas.height = VIEWPORT_HEIGHT;
            
            if (isLandscape) {
                const maxHeight = window.innerHeight * 0.9;
                const scale = maxHeight / VIEWPORT_HEIGHT;
                canvas.style.width = (VIEWPORT_WIDTH * scale) + 'px';
                canvas.style.height = (VIEWPORT_HEIGHT * scale) + 'px';
            } else {
                const maxWidth = window.innerWidth * 0.95;
                const scale = Math.min(maxWidth / VIEWPORT_WIDTH, window.innerHeight * 0.7 / VIEWPORT_HEIGHT);
                canvas.style.width = (VIEWPORT_WIDTH * scale) + 'px';
                canvas.style.height = (VIEWPORT_HEIGHT * scale) + 'px';
            }
            
            minimapCanvas.width = 160;
            minimapCanvas.height = 120;
        }
        
        resizeCanvas();
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (gameState === 'playing') {
                draw();
            }
        });
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                resizeCanvas();
                if (gameState === 'playing') {
                    draw();
                }
            }, 100);
        });
        
        let gameState = 'start';
        let startTime = 0;
        let gameTime = 0;
        let difficulty = 'easy';
        let lives = 3;
        let soundEnabled = true;
        
        // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Ç∑„Çπ„ÉÜ„É†
        let particles = [];
        
        class Particle {
            constructor(x, y, color, size, vx, vy, lifetime) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.vx = vx;
                this.vy = vy;
                this.lifetime = lifetime;
                this.age = 0;
                this.alpha = 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // ÈáçÂäõ
                this.age++;
                this.alpha = 1 - (this.age / this.lifetime);
                return this.age < this.lifetime;
            }
            
            draw(ctx) {
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                particles.push(new Particle(
                    x, y, color,
                    Math.random() * 4 + 2,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed - 2,
                    30 + Math.random() * 30
                ));
            }
        }
        
        function updateParticles() {
            particles = particles.filter(p => p.update());
        }
        
        function drawParticles() {
            particles.forEach(p => p.draw(ctx));
        }
        
        // ÁîªÈù¢„Ç®„Éï„Çß„ÇØ„Éà
        function screenShake() {
            document.getElementById('gameContainer').classList.add('screen-shake');
            setTimeout(() => {
                document.getElementById('gameContainer').classList.remove('screen-shake');
            }, 500);
        }
        
        function damageFlash() {
            document.getElementById('screenEffects').classList.add('damage-flash');
            setTimeout(() => {
                document.getElementById('screenEffects').classList.remove('damage-flash');
            }, 300);
        }
        
        function updateVignette() {
            let minDist = Infinity;
            teachers.forEach(t => {
                const dx = player.x - t.x;
                const dy = player.y - t.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) minDist = dist;
            });
            
            if (minDist < 300) {
                document.getElementById('screenEffects').classList.add('vignette');
            } else {
                document.getElementById('screenEffects').classList.remove('vignette');
            }
        }
        
        // „Çµ„Ç¶„É≥„Éâ
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'task':
                    oscillator.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'powerup':
                    oscillator.frequency.value = 1000;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'hit':
                    oscillator.frequency.value = 200;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'clear':
                    oscillator.frequency.value = 1200;
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                case 'hide':
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').textContent = soundEnabled ? 'üîä' : 'üîá';
        }
        
        // Áµ±Ë®à„ÉªÂÆüÁ∏æ„Ç∑„Çπ„ÉÜ„É†
        let stats = {
            totalPlayTime: 0,
            totalClears: 0,
            totalDeaths: 0,
            bestTime: Infinity,
            totalPowerups: 0,
            totalHides: 0,
            noDamageClears: 0,
            fastClears: 0,
            hardClears: 0
        };
        
        const achievements = [
            {id: 'first_clear', name: 'ÂàùËÑ±Âá∫', desc: 'Âàù„ÇÅ„Å¶„ÇØ„É™„Ç¢', icon: 'üéâ', check: () => stats.totalClears >= 1},
            {id: 'speed_demon', name: '„Çπ„Éî„Éº„Éâ„É©„É≥„Éä„Éº', desc: '3ÂàÜ‰ª•ÂÜÖ„Å´„ÇØ„É™„Ç¢', icon: '‚ö°', check: () => stats.bestTime <= 180},
            {id: 'survivor', name: 'ÁîüÂ≠òËÄÖ', desc: '„ÉÄ„É°„Éº„Ç∏„Å™„Åó„Åß„ÇØ„É™„Ç¢', icon: 'üí™', check: () => stats.noDamageClears >= 1},
            {id: 'veteran', name: '„Éô„ÉÜ„É©„É≥', desc: '10Âõû„ÇØ„É™„Ç¢', icon: 'üèÜ', check: () => stats.totalClears >= 10},
            {id: 'powerup_master', name: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Éû„Çπ„Çø„Éº', desc: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó50ÂÄãÂèñÂæó', icon: '‚≠ê', check: () => stats.totalPowerups >= 50},
            {id: 'hide_expert', name: 'Èö†„Çå‰∏äÊâã', desc: '20ÂõûÈö†„Çå„Çã', icon: 'üö™', check: () => stats.totalHides >= 20},
            {id: 'hard_clear', name: '„Éè„Éº„Éâ„ÇØ„É™„Ç¢', desc: '„Éè„Éº„Éâ„É¢„Éº„Éâ„Åß„ÇØ„É™„Ç¢', icon: 'üò±', check: () => stats.hardClears >= 1},
            {id: 'speedrun_god', name: '„Çπ„Éî„Éº„Éâ„É©„É≥Á•û', desc: '2ÂàÜ‰ª•ÂÜÖ„Å´„ÇØ„É™„Ç¢', icon: 'üî•', check: () => stats.bestTime <= 120},
            {id: 'marathon', name: '„Éû„É©„ÇΩ„É≥„É©„É≥„Éä„Éº', desc: 'Á¥ØË®à1ÊôÇÈñì„Éó„É¨„Ç§', icon: 'üèÉ', check: () => stats.totalPlayTime >= 3600},
            {id: 'perfectionist', name: 'ÂÆåÁíß‰∏ªÁæ©ËÄÖ', desc: '„Éé„Éº„ÉÄ„É°„Éº„Ç∏„Éè„Éº„Éâ„ÇØ„É™„Ç¢', icon: 'üëë', check: () => stats.noDamageClears >= 1 && stats.hardClears >= 1}
        ];
        
        let unlockedAchievements = [];
        
        function loadStats() {
            const saved = localStorage.getItem('gameStats');
            if (saved) {
                stats = JSON.parse(saved);
            }
            const savedAchievements = localStorage.getItem('unlockedAchievements');
            if (savedAchievements) {
                unlockedAchievements = JSON.parse(savedAchievements);
            }
        }
        
        function saveStats() {
            localStorage.setItem('gameStats', JSON.stringify(stats));
            localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedAchievements));
        }
        
        function checkAchievements() {
            const newAchievements = [];
            achievements.forEach(ach => {
                if (!unlockedAchievements.includes(ach.id) && ach.check()) {
                    unlockedAchievements.push(ach.id);
                    newAchievements.push(ach);
                }
            });
            return newAchievements;
        }
        
        function showStats() {
            loadStats();
            
            const mins = Math.floor(stats.totalPlayTime / 60);
            const bestMins = Math.floor(stats.bestTime / 60);
            const bestSecs = stats.bestTime % 60;
            
            document.getElementById('totalPlayTime').textContent = mins + 'ÂàÜ';
            document.getElementById('totalClears').textContent = stats.totalClears + 'Âõû';
            document.getElementById('totalDeaths').textContent = stats.totalDeaths + 'Âõû';
            document.getElementById('bestTime').textContent = stats.bestTime === Infinity ? '--:--' : 
                `${bestMins}:${bestSecs.toString().padStart(2, '0')}`;
            document.getElementById('totalPowerups').textContent = stats.totalPowerups + 'ÂÄã';
            document.getElementById('totalHides').textContent = stats.totalHides + 'Âõû';
            
            const achievementList = document.getElementById('achievementList');
            achievementList.innerHTML = '';
            
            achievements.forEach(ach => {
                const unlocked = unlockedAchievements.includes(ach.id);
                const div = document.createElement('div');
                div.className = 'achievement' + (unlocked ? ' unlocked' : '');
                div.innerHTML = `
                    <div class="achievement-icon">${unlocked ? ach.icon : 'üîí'}</div>
                    <div class="achievement-info">
                        <h4>${ach.name}</h4>
                        <p>${ach.desc}</p>
                    </div>
                `;
                achievementList.appendChild(div);
            });
            
            document.getElementById('achievementCount').textContent = 
                `${unlockedAchievements.length}/${achievements.length}`;
            
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('clearScreen').classList.add('hidden');
            document.getElementById('statsScreen').classList.remove('hidden');
        }
        
        function closeStats() {
            document.getElementById('statsScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        }
        
        function resetStats() {
            if (confirm('Êú¨ÂΩì„Å´Áµ±Ë®à„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü')) {
                stats = {
                    totalPlayTime: 0,
                    totalClears: 0,
                    totalDeaths: 0,
                    bestTime: Infinity,
                    totalPowerups: 0,
                    totalHides: 0,
                    noDamageClears: 0,
                    fastClears: 0,
                    hardClears: 0
                };
                unlockedAchievements = [];
                saveStats();
                localStorage.removeItem('highScores');
                showStats();
            }
        }
        
        const difficultySettings = {
            easy: {
                playerSpeed: 2.5,
                teacherSpeed: 1.4,
                teacherCount: 2,
                taskCount: 4,
                lives: 3,
                label: '„Ç§„Éº„Ç∏„Éº'
            },
            normal: {
                playerSpeed: 2.2,
                teacherSpeed: 1.6,
                teacherCount: 3,
                taskCount: 6,
                lives: 3,
                label: '„Éé„Éº„Éû„É´'
            },
            hard: {
                playerSpeed: 2.0,
                teacherSpeed: 2.0,
                teacherCount: 4,
                taskCount: 8,
                lives: 2,
                label: '„Éè„Éº„Éâ'
            }
        };
        
        function selectDifficulty(level) {
            difficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }
        
        const player = {
            x: 100,
            y: 100,
            size: 30,
            speed: 2.2,
            color: '#4ecca3',
            angle: 0,
            animFrame: 0
        };
        
        let teachers = [];
        
        function createTeacher(x, y) {
            return {
                x: x,
                y: y,
                size: 35,
                speed: 1.5,
                color: '#e94560',
                chaseRange: 1200,
                patrolTarget: {x: 400, y: 300},
                patrolTimer: 0,
                angle: 0,
                animFrame: 0
            };
        }
        
        const walls = [
            {x: 0, y: 0, width: GAME_WIDTH, height: 20},
            {x: 0, y: 0, width: 20, height: GAME_HEIGHT},
            {x: GAME_WIDTH - 20, y: 0, width: 20, height: GAME_HEIGHT},
            {x: 0, y: GAME_HEIGHT - 20, width: GAME_WIDTH, height: 20},
            {x: 150, y: 150, width: 200, height: 150},
            {x: 400, y: 100, width: 150, height: 200},
            {x: 700, y: 80, width: 120, height: 180},
            {x: 900, y: 150, width: 180, height: 100},
            {x: 1150, y: 100, width: 150, height: 180},
            {x: 1400, y: 150, width: 120, height: 150},
            {x: 120, y: 450, width: 150, height: 100},
            {x: 350, y: 500, width: 120, height: 150},
            {x: 600, y: 400, width: 100, height: 250},
            {x: 800, y: 450, width: 180, height: 80},
            {x: 1050, y: 400, width: 120, height: 200},
            {x: 1250, y: 480, width: 100, height: 150},
            {x: 1420, y: 500, width: 130, height: 120},
            {x: 180, y: 800, width: 150, height: 100},
            {x: 400, y: 850, width: 100, height: 150},
            {x: 650, y: 800, width: 120, height: 150},
            {x: 850, y: 900, width: 150, height: 100},
            {x: 1100, y: 850, width: 100, height: 120},
            {x: 1300, y: 900, width: 150, height: 100},
            {x: 500, y: 300, width: 60, height: 60},
            {x: 300, y: 650, width: 70, height: 70},
            {x: 950, y: 650, width: 80, height: 80},
            {x: 1350, y: 350, width: 60, height: 60},
            {x: 750, y: 750, width: 50, height: 50},
        ];
        
        // „É≠„ÉÉ„Ç´„Éº
        const lockers = [
            {x: 450, y: 450, width: 40, height: 60, occupied: false},
            {x: 1200, y: 250, width: 40, height: 60, occupied: false},
            {x: 600, y: 1050, width: 40, height: 60, occupied: false},
            {x: 200, y: 600, width: 40, height: 60, occupied: false},
            {x: 1350, y: 700, width: 40, height: 60, occupied: false},
        ];
        
        let nearestLocker = null;
        let hiding = false;
        let hideTime = 0;
        let damageTaken = false;
        
        function checkNearLocker() {
            nearestLocker = null;
            let minDist = Infinity;
            
            lockers.forEach(locker => {
                if (locker.occupied) return;
                const dx = player.x - (locker.x + locker.width / 2);
                const dy = player.y - (locker.y + locker.height / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 80 && dist < minDist) {
                    minDist = dist;
                    nearestLocker = locker;
                }
            });
            
            const hideBtn = document.getElementById('hideButton');
            if (nearestLocker && !hiding) {
                hideBtn.classList.add('show');
            } else {
                hideBtn.classList.remove('show');
            }
        }
        
        function enterLocker() {
            if (!nearestLocker || hiding) return;
            
            hiding = true;
            hideTime = 0;
            nearestLocker.occupied = true;
            player.x = nearestLocker.x + nearestLocker.width / 2;
            player.y = nearestLocker.y + nearestLocker.height / 2;
            document.getElementById('hidingStatus').style.display = 'block';
            document.getElementById('hideButton').classList.remove('show');
            playSound('hide');
            stats.totalHides++;
        }
        
        function exitLocker() {
            hiding = false;
            if (nearestLocker) {
                nearestLocker.occupied = false;
            }
            document.getElementById('hidingStatus').style.display = 'none';
        }
        
        const tasks = [];
        const powerups = [];
        let activePowerup = null;
        let powerupTimer = 0;
        
        const powerupTypes = {
            speed: {icon: 'üöÄ', duration: 300, color: '#3498db'},
            invisible: {icon: 'üëª', duration: 300, color: '#9b59b6'},
            freeze: {icon: '‚è∏Ô∏è', duration: 180, color: '#e74c3c'}
        };
        
        let currentTask = null;
        let taskProgress = 0;
        const TASK_COMPLETION_TIME = 120;
        
        const exit = {
            x: 1500,
            y: 1100,
            width: 40,
            height: 60,
            open: false
        };
        
        let joystick = {
            active: false,
            dx: 0,
            dy: 0
        };
        
        const joystickStick = document.getElementById('joystickStick');
        const joystickBase = document.getElementById('joystickBase');
        
        joystickBase.addEventListener('touchstart', handleJoystickStart, {passive: false});
        joystickStick.addEventListener('touchstart', handleJoystickStart, {passive: false});
        document.addEventListener('touchmove', handleJoystickMove, {passive: false});
        document.addEventListener('touchend', handleJoystickEnd, {passive: false});
        
        function handleJoystickStart(e) {
            e.preventDefault();
            joystick.active = true;
            
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2 - 10;
            
            if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
            }
            
            joystickStick.style.left = (rect.width / 2 - 30 + dx) + 'px';
            joystickStick.style.top = (rect.height / 2 - 30 + dy) + 'px';
            
            joystick.dx = dx / maxDistance;
            joystick.dy = dy / maxDistance;
        }
        
        function handleJoystickMove(e) {
            if (!joystick.active) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2 - 10;
            
            if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
            }
            
            joystickStick.style.left = (rect.width / 2 - 30 + dx) + 'px';
            joystickStick.style.top = (rect.height / 2 - 30 + dy) + 'px';
            
            joystick.dx = dx / maxDistance;
            joystick.dy = dy / maxDistance;
        }
        
        function handleJoystickEnd(e) {
            if (!joystick.active) return;
            e.preventDefault();
            
            joystick.active = false;
            joystick.dx = 0;
            joystick.dy = 0;
            
            const rect = joystickBase.getBoundingClientRect();
            joystickStick.style.left = (rect.width / 2 - 30) + 'px';
            joystickStick.style.top = (rect.height / 2 - 30) + 'px';
        }
        
        function saveScore(time, difficulty) {
            const scores = JSON.parse(localStorage.getItem('highScores') || '[]');
            scores.push({time, difficulty, date: new Date().toISOString()});
            scores.sort((a, b) => a.time - b.time);
            localStorage.setItem('highScores', JSON.stringify(scores.slice(0, 10)));
        }
        
        function loadHighScores() {
            const scores = JSON.parse(localStorage.getItem('highScores') || '[]');
            const scoreList = document.getElementById('scoreList');
            
            if (scores.length > 0) {
                document.getElementById('highScores').classList.remove('hidden');
                scoreList.innerHTML = scores.slice(0, 5).map((score, i) => {
                    const mins = Math.floor(score.time / 60);
                    const secs = score.time % 60;
                    return `<li>${mins}:${secs.toString().padStart(2, '0')} (${difficultySettings[score.difficulty].label})</li>`;
                }).join('');
            }
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            gameState = 'playing';
            startTime = Date.now();
            damageTaken = false;
            resetGame();
            gameLoop();
        }
        
        function resetGame() {
            const settings = difficultySettings[difficulty];
            
            player.x = 100;
            player.y = 100;
            player.speed = settings.playerSpeed;
            player.animFrame = 0;
            
            teachers = [];
            for (let i = 0; i < settings.teacherCount; i++) {
                if (i === 0) {
                    teachers.push(createTeacher(250, 350));
                } else if (i === 1) {
                    teachers.push(createTeacher(1350, 350));
                } else if (i === 2) {
                    teachers.push(createTeacher(250, 1050));
                } else if (i === 3) {
                    teachers.push(createTeacher(1350, 1050));
                }
            }
            teachers.forEach(t => {
                t.speed = settings.teacherSpeed;
                t.animFrame = 0;
            });
            
            lives = settings.lives;
            randomizeTasks(settings.taskCount);
            randomizePowerups();
            exit.open = false;
            startTime = Date.now();
            currentTask = null;
            taskProgress = 0;
            activePowerup = null;
            powerupTimer = 0;
            hiding = false;
            hideTime = 0;
            lockers.forEach(l => l.occupied = false);
            particles = [];
            document.getElementById('progressBarContainer').classList.remove('active');
            document.getElementById('hidingStatus').style.display = 'none';
            document.getElementById('hideButton').classList.remove('show');
            updateLivesDisplay();
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('clearScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            gameState = 'start';
            loadHighScores();
        }
        
        function checkCollision(obj1, obj2, size1, size2) {
            return Math.abs(obj1.x - obj2.x) < (size1 + size2) / 2 &&
                   Math.abs(obj1.y - obj2.y) < (size1 + size2) / 2;
        }
        
        function checkWallCollision(x, y, size) {
            for (let wall of walls) {
                if (x - size / 2 < wall.x + wall.width &&
                    x + size / 2 > wall.x &&
                    y - size / 2 < wall.y + wall.height &&
                    y + size / 2 > wall.y) {
                    return true;
                }
            }
            return false;
        }
        
        function randomizeTasks(count) {
            tasks.length = 0;
            
            for (let i = 1; i <= count; i++) {
                let x, y, attempts = 0;
                
                do {
                    x = 50 + Math.random() * (GAME_WIDTH - 100);
                    y = 50 + Math.random() * (GAME_HEIGHT - 100);
                    attempts++;
                    if (attempts > 100) break;
                } while (checkWallCollision(x, y, 30));
                
                tasks.push({
                    x, y,
                    size: 20,
                    completed: false,
                    label: `Êï∞Âºè${i}`,
                    pulse: 0
                });
            }
        }
        
        function randomizePowerups() {
            powerups.length = 0;
            const types = Object.keys(powerupTypes);
            
            for (let i = 0; i < 6; i++) {
                let x, y, attempts = 0;
                
                do {
                    x = 50 + Math.random() * (GAME_WIDTH - 100);
                    y = 50 + Math.random() * (GAME_HEIGHT - 100);
                    attempts++;
                    if (attempts > 100) break;
                } while (checkWallCollision(x, y, 30));
                
                powerups.push({
                    x, y,
                    size: 15,
                    type: types[i % types.length],
                    collected: false,
                    pulse: Math.random() * Math.PI * 2
                });
            }
        }
        
        function updateLivesDisplay() {
            document.getElementById('lives').textContent = '‚ù§Ô∏è √ó' + lives;
        }
        
        function updatePlayer() {
            if (hiding) {
                hideTime++;
                if (hideTime > 600) { // 10Áßí„ÅßÂº∑Âà∂ÈÄÄÂá∫
                    exitLocker();
                }
                
                // Èö†„Çå„Å¶„ÅÑ„ÇãÈñì„ÇÇ„Çø„ÉÉ„Éó„ÅßÂá∫„Çâ„Çå„Çã
                if (joystick.dx !== 0 || joystick.dy !== 0) {
                    exitLocker();
                }
                return;
            }
            
            let speedMultiplier = 1;
            if (activePowerup === 'speed') speedMultiplier = 1.8;
            
            const newX = player.x + joystick.dx * player.speed * speedMultiplier;
            const newY = player.y + joystick.dy * player.speed * speedMultiplier;
            
            if (!checkWallCollision(newX, player.y, player.size)) {
                player.x = newX;
                if (joystick.dx !== 0) player.animFrame++;
            }
            if (!checkWallCollision(player.x, newY, player.size)) {
                player.y = newY;
                if (joystick.dy !== 0) player.animFrame++;
            }
            
            if (joystick.dx !== 0 || joystick.dy !== 0) {
                player.angle = Math.atan2(joystick.dy, joystick.dx);
            }
            
            checkNearLocker();
            
            powerups.forEach(powerup => {
                if (!powerup.collected && checkCollision(player, powerup, player.size, powerup.size * 2)) {
                    powerup.collected = true;
                    activePowerup = powerup.type;
                    powerupTimer = powerupTypes[powerup.type].duration;
                    playSound('powerup');
                    createParticles(powerup.x, powerup.y, powerupTypes[powerup.type].color, 20);
                    stats.totalPowerups++;
                }
            });
            
            let nearTask = null;
            tasks.forEach(task => {
                if (!task.completed && checkCollision(player, task, player.size, task.size * 3)) {
                    nearTask = task;
                }
            });
            
            if (nearTask) {
                currentTask = nearTask;
                taskProgress++;
                
                const progress = Math.min(100, (taskProgress / TASK_COMPLETION_TIME) * 100);
                document.getElementById('progressBarFill').style.width = progress + '%';
                document.getElementById('progressBarContainer').classList.add('active');
                
                if (taskProgress >= TASK_COMPLETION_TIME) {
                    nearTask.completed = true;
                    taskProgress = 0;
                    currentTask = null;
                    document.getElementById('progressBarContainer').classList.remove('active');
                    playSound('task');
                    createParticles(nearTask.x, nearTask.y, '#f39c12', 30);
                    
                    if (tasks.every(t => t.completed)) {
                        exit.open = true;
                        createParticles(exit.x + exit.width / 2, exit.y + exit.height / 2, '#4ecca3', 40);
                    }
                }
            } else {
                if (currentTask) {
                    taskProgress = 0;
                    currentTask = null;
                    document.getElementById('progressBarContainer').classList.remove('active');
                    document.getElementById('progressBarFill').style.width = '0%';
                }
            }
            
            if (exit.open && 
                player.x > exit.x && player.x < exit.x + exit.width &&
                player.y > exit.y && player.y < exit.y + exit.height) {
                gameClear();
            }
            
            if (activePowerup) {
                powerupTimer--;
                if (powerupTimer <= 0) {
                    activePowerup = null;
                }
                
                const powerupName = activePowerup === 'speed' ? '„Çπ„Éî„Éº„Éâ' :
                                   activePowerup === 'invisible' ? 'ÈÄèÊòéÂåñ' : 'ÊôÇÈñìÂÅúÊ≠¢';
                const timeLeft = Math.ceil(powerupTimer / 60);
                document.getElementById('powerupStatus').textContent = 
                    `‚ö° ${powerupName} (${timeLeft}Áßí)`;
            } else {
                document.getElementById('powerupStatus').textContent = '';
            }
        }
        
        function updateTeacher(teacher) {
            if (activePowerup === 'freeze') return;
            
            const dx = player.x - teacher.x;
            const dy = player.y - teacher.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const canSeePlayer = activePowerup !== 'invisible' && !hiding;
            
            if (canSeePlayer && distance < teacher.chaseRange) {
                const angle = Math.atan2(dy, dx);
                teacher.angle = angle;
                const newX = teacher.x + Math.cos(angle) * teacher.speed;
                const newY = teacher.y + Math.sin(angle) * teacher.speed;
                
                if (!checkWallCollision(newX, teacher.y, teacher.size)) {
                    teacher.x = newX;
                    teacher.animFrame++;
                }
                if (!checkWallCollision(teacher.x, newY, teacher.size)) {
                    teacher.y = newY;
                    teacher.animFrame++;
                }
            } else {
                teacher.patrolTimer++;
                
                if (teacher.patrolTimer > 180) {
                    teacher.patrolTarget.x = 100 + Math.random() * (GAME_WIDTH - 200);
                    teacher.patrolTarget.y = 100 + Math.random() * (GAME_HEIGHT - 200);
                    teacher.patrolTimer = 0;
                }
                
                const dx = teacher.patrolTarget.x - teacher.x;
                const dy = teacher.patrolTarget.y - teacher.y;
                const angle = Math.atan2(dy, dx);
                teacher.angle = angle;
                
                const newX = teacher.x + Math.cos(angle) * teacher.speed * 0.7;
                const newY = teacher.y + Math.sin(angle) * teacher.speed * 0.7;
                
                if (!checkWallCollision(newX, teacher.y, teacher.size)) {
                    teacher.x = newX;
                    teacher.animFrame++;
                }
                if (!checkWallCollision(teacher.x, newY, teacher.size)) {
                    teacher.y = newY;
                    teacher.animFrame++;
                }
            }
            
            if (!hiding && activePowerup !== 'invisible' && checkCollision(player, teacher, player.size, teacher.size)) {
                lives--;
                updateLivesDisplay();
                playSound('hit');
                screenShake();
                damageFlash();
                damageTaken = true;
                createParticles(player.x, player.y, '#e94560', 25);
                
                if (lives <= 0) {
                    gameOver();
                } else {
                    player.x = 100;
                    player.y = 100;
                }
            }
        }
        
        function updateCamera() {
            camera.x = player.x - VIEWPORT_WIDTH / 2;
            camera.y = player.y - VIEWPORT_HEIGHT / 2;
            
            camera.x = Math.max(0, Math.min(camera.x, GAME_WIDTH - VIEWPORT_WIDTH));
            camera.y = Math.max(0, Math.min(camera.y, GAME_HEIGHT - VIEWPORT_HEIGHT));
        }
        
        function draw() {
            updateCamera();
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            
            // ËÉåÊôØ„ÉÜ„ÇØ„Çπ„ÉÅ„É£
            const gradient = ctx.createLinearGradient(camera.x, camera.y, camera.x + VIEWPORT_WIDTH, camera.y + VIEWPORT_HEIGHT);
            gradient.addColorStop(0, '#2d2d44');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(camera.x, camera.y, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
            
            // „Ç∞„É™„ÉÉ„ÉâÔºàÂ∫ä„Çø„Ç§„É´È¢®Ôºâ
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 2;
            const gridStartX = Math.floor(camera.x / 80) * 80;
            const gridStartY = Math.floor(camera.y / 80) * 80;
            for (let i = gridStartX; i < camera.x + VIEWPORT_WIDTH; i += 80) {
                for (let j = gridStartY; j < camera.y + VIEWPORT_HEIGHT; j += 80) {
                    ctx.strokeRect(i, j, 80, 80);
                }
            }
            
            // Â£ÅÔºà3DÈ¢®Ôºâ
            walls.forEach(wall => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(wall.x + 4, wall.y + 4, wall.width, wall.height);
                
                const wallGradient = ctx.createLinearGradient(wall.x, wall.y, wall.x + wall.width, wall.y + wall.height);
                wallGradient.addColorStop(0, '#777');
                wallGradient.addColorStop(0.5, '#555');
                wallGradient.addColorStop(1, '#333');
                ctx.fillStyle = wallGradient;
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(wall.x, wall.y, wall.width, 4);
                ctx.fillRect(wall.x, wall.y, 4, wall.height);
            });
            
            // „É≠„ÉÉ„Ç´„Éº
            lockers.forEach(locker => {
                ctx.shadowBlur = locker === nearestLocker ? 15 : 0;
                ctx.shadowColor = '#4ecca3';
                
                const lockerGrad = ctx.createLinearGradient(locker.x, locker.y, locker.x + locker.width, locker.y + locker.height);
                lockerGrad.addColorStop(0, locker.occupied ? '#555' : '#8B4513');
                lockerGrad.addColorStop(1, locker.occupied ? '#333' : '#654321');
                ctx.fillStyle = lockerGrad;
                ctx.fillRect(locker.x, locker.y, locker.width, locker.height);
                
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = locker === nearestLocker ? '#4ecca3' : '#333';
                ctx.lineWidth = 3;
                ctx.strokeRect(locker.x, locker.y, locker.width, locker.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üö™', locker.x + locker.width / 2, locker.y - 10);
            });
            
            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó
            powerups.forEach(powerup => {
                if (powerup.collected) return;
                
                powerup.pulse += 0.1;
                const pulseSize = Math.sin(powerup.pulse) * 3;
                
                ctx.shadowColor = powerupTypes[powerup.type].color;
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = powerupTypes[powerup.type].color;
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, powerup.size + pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerupTypes[powerup.type].icon, powerup.x, powerup.y + 7);
            });
            
            // „Çø„Çπ„ÇØ
            tasks.forEach(task => {
                task.pulse += 0.1;
                const pulseSize = Math.sin(task.pulse) * 3;
                
                if (!task.completed) {
                    ctx.shadowColor = '#f39c12';
                    ctx.shadowBlur = 20 + pulseSize;
                    
                    const taskGradient = ctx.createRadialGradient(task.x, task.y, 5, task.x, task.y, task.size + pulseSize);
                    taskGradient.addColorStop(0, '#f39c12');
                    taskGradient.addColorStop(1, '#e67e22');
                    ctx.fillStyle = taskGradient;
                    ctx.beginPath();
                    ctx.arc(task.x, task.y, task.size + pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 4;
                    ctx.fillText(task.label, task.x, task.y - 30);
                    ctx.shadowBlur = 0;
                    
                    if (currentTask === task) {
                        ctx.strokeStyle = 'rgba(243, 156, 18, 0.3)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(task.x, task.y, task.size * 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else {
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.arc(task.x, task.y, task.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#4ecca3';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 4;
                    ctx.fillText('‚úì', task.x, task.y + 8);
                    ctx.shadowBlur = 0;
                }
            });
            
            // Âá∫Âè£
            if (exit.open) {
                ctx.shadowColor = '#4ecca3';
                ctx.shadowBlur = 25;
                ctx.fillStyle = '#4ecca3';
            } else {
                ctx.fillStyle = '#555';
            }
            ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText('Âá∫Âè£', exit.x + exit.width / 2, exit.y - 15);
            ctx.shadowBlur = 0;
            
            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´
            drawParticles();
            
            // „Éó„É¨„Ç§„É§„Éº
            drawPlayer();
            
            // Âä†Ëó§ÂÖàÁîü
            teachers.forEach(teacher => drawTeacher(teacher));
            
            ctx.restore();
            
            drawDirectionIndicators();
            drawMinimap();
        }
        
        function drawPlayer() {
            if (hiding) {
                ctx.globalAlpha = 0.3;
            } else {
                const opacity = activePowerup === 'invisible' ? 0.3 : 1;
                ctx.globalAlpha = opacity;
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(player.x + 2, player.y + player.size / 2 + 2, player.size / 2, player.size / 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 15;
            
            const playerGradient = ctx.createRadialGradient(
                player.x - player.size / 4, 
                player.y - player.size / 4, 
                0,
                player.x, 
                player.y, 
                player.size / 2
            );
            playerGradient.addColorStop(0, '#6effd5');
            playerGradient.addColorStop(1, player.color);
            ctx.fillStyle = playerGradient;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            const eyeOffsetX = Math.cos(player.angle) * 5;
            const eyeOffsetY = Math.sin(player.angle) * 5;
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(player.x + eyeOffsetX - 4, player.y + eyeOffsetY - 3, 3, 0, Math.PI * 2);
            ctx.arc(player.x + eyeOffsetX + 4, player.y + eyeOffsetY - 3, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(player.x + eyeOffsetX - 3, player.y + eyeOffsetY - 3, 1.5, 0, Math.PI * 2);
            ctx.arc(player.x + eyeOffsetX + 5, player.y + eyeOffsetY - 3, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            if (!hiding) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText('YOU', player.x, player.y + player.size / 2 + 18);
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1;
        }
        
        function drawTeacher(teacher) {
            const frozen = activePowerup === 'freeze';
            
            if (frozen) {
                ctx.globalAlpha = 0.5;
            }
            
            const dx = player.x - teacher.x;
            const dy = player.y - teacher.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (gameState === 'playing' && activePowerup !== 'invisible' && !hiding) {
                if (distance < teacher.chaseRange) {
                    ctx.strokeStyle = 'rgba(233, 69, 96, 0.15)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(teacher.x, teacher.y, teacher.chaseRange, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(teacher.x + 3, teacher.y + teacher.size / 2 + 3, teacher.size / 2, teacher.size / 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowColor = teacher.color;
            ctx.shadowBlur = 20;
            
            const teacherGradient = ctx.createRadialGradient(
                teacher.x - teacher.size / 4, 
                teacher.y - teacher.size / 4, 
                0,
                teacher.x, 
                teacher.y, 
                teacher.size / 2
            );
            teacherGradient.addColorStop(0, '#ff6b88');
            teacherGradient.addColorStop(1, teacher.color);
            ctx.fillStyle = teacherGradient;
            ctx.beginPath();
            ctx.arc(teacher.x, teacher.y, teacher.size / 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            if (distance < teacher.chaseRange && !frozen && !hiding) {
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üí¢', teacher.x + 15, teacher.y - 15);
            }
            
            if (frozen) {
                ctx.fillStyle = '#3498db';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ùÑÔ∏è', teacher.x, teacher.y - 20);
            }
            
            const eyeOffsetX = Math.cos(teacher.angle) * 6;
            const eyeOffsetY = Math.sin(teacher.angle) * 6;
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(teacher.x + eyeOffsetX - 5, teacher.y + eyeOffsetY - 4, 4, 0, Math.PI * 2);
            ctx.arc(teacher.x + eyeOffsetX + 5, teacher.y + eyeOffsetY - 4, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(teacher.x + eyeOffsetX - 4, teacher.y + eyeOffsetY - 4, 2, 0, Math.PI * 2);
            ctx.arc(teacher.x + eyeOffsetX + 6, teacher.y + eyeOffsetY - 4, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText('Âä†Ëó§ÂÖàÁîü', teacher.x, teacher.y + teacher.size / 2 + 22);
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = 1;
        }
        
        function drawDirectionIndicators() {
            const margin = 40;
            const arrowSize = 30;
            
            tasks.forEach(task => {
                if (!task.completed) {
                    drawIndicator(task.x, task.y, 'üìù', '#f39c12', margin, arrowSize);
                }
            });
            
            powerups.forEach(powerup => {
                if (!powerup.collected) {
                    const icon = powerupTypes[powerup.type].icon;
                    drawIndicator(powerup.x, powerup.y, icon, powerupTypes[powerup.type].color, margin, arrowSize);
                }
            });
            
            if (exit.open) {
                drawIndicator(exit.x + exit.width / 2, exit.y + exit.height / 2, 'üö™', '#4ecca3', margin, arrowSize);
            }
        }
        
        function drawIndicator(targetX, targetY, icon, color, margin, arrowSize) {
            const viewLeft = camera.x;
            const viewRight = camera.x + VIEWPORT_WIDTH;
            const viewTop = camera.y;
            const viewBottom = camera.y + VIEWPORT_HEIGHT;
            
            if (targetX >= viewLeft && targetX <= viewRight &&
                targetY >= viewTop && targetY <= viewBottom) {
                return;
            }
            
            const dx = targetX - player.x;
            const dy = targetY - player.y;
            const angle = Math.atan2(dy, dx);
            
            let indicatorX, indicatorY;
            
            const centerX = VIEWPORT_WIDTH / 2;
            const centerY = VIEWPORT_HEIGHT / 2;
            
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const distToEdgeX = cos > 0 ? (VIEWPORT_WIDTH / 2 - margin) : (-VIEWPORT_WIDTH / 2 + margin);
            const distToEdgeY = sin > 0 ? (VIEWPORT_HEIGHT / 2 - margin) : (-VIEWPORT_HEIGHT / 2 + margin);
            
            const tX = Math.abs(distToEdgeX / cos);
            const tY = Math.abs(distToEdgeY / sin);
            const t = Math.min(tX, tY);
            
            indicatorX = centerX + cos * t;
            indicatorY = centerY + sin * t;
            
            ctx.save();
            ctx.translate(indicatorX, indicatorY);
            ctx.rotate(angle);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(arrowSize / 2, 0);
            ctx.lineTo(-arrowSize / 2, -arrowSize / 3);
            ctx.lineTo(-arrowSize / 2, arrowSize / 3);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.rotate(-angle);
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(icon, -arrowSize, 0);
            
            ctx.restore();
        }
        
        function drawMinimap() {
            const scale = 0.1;
            
            minimapCtx.fillStyle = '#1a1a2e';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            minimapCtx.fillStyle = '#555';
            walls.forEach(wall => {
                minimapCtx.fillRect(wall.x * scale, wall.y * scale, wall.width * scale, wall.height * scale);
            });
            
            minimapCtx.fillStyle = '#8B4513';
            lockers.forEach(locker => {
                minimapCtx.fillRect(locker.x * scale, locker.y * scale, locker.width * scale, locker.height * scale);
            });
            
            tasks.forEach(task => {
                minimapCtx.fillStyle = task.completed ? '#888' : '#f39c12';
                minimapCtx.beginPath();
                minimapCtx.arc(task.x * scale, task.y * scale, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            powerups.forEach(powerup => {
                if (!powerup.collected) {
                    minimapCtx.fillStyle = powerupTypes[powerup.type].color;
                    minimapCtx.beginPath();
                    minimapCtx.arc(powerup.x * scale, powerup.y * scale, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            minimapCtx.fillStyle = exit.open ? '#4ecca3' : '#555';
            minimapCtx.fillRect(exit.x * scale, exit.y * scale, exit.width * scale, exit.height * scale);
            
            minimapCtx.fillStyle = '#e94560';
            teachers.forEach(teacher => {
                minimapCtx.beginPath();
                minimapCtx.arc(teacher.x * scale, teacher.y * scale, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            minimapCtx.fillStyle = '#4ecca3';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale, 4, 0, Math.PI * 2);
            minimapCtx.fill();
        }
        
        function updateUI() {
            const completedTasks = tasks.filter(t => t.completed).length;
            const totalTasks = tasks.length;
            document.getElementById('taskCount').textContent = `${completedTasks}/${totalTasks}`;
            
            gameTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            document.getElementById('timer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function gameOver() {
            gameState = 'gameover';
            stats.totalDeaths++;
            stats.totalPlayTime += gameTime;
            saveStats();
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        function gameClear() {
            gameState = 'clear';
            playSound('clear');
            createParticles(player.x, player.y, '#4ecca3', 50);
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            document.getElementById('finalTime').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            stats.totalClears++;
            stats.totalPlayTime += gameTime;
            
            if (gameTime < stats.bestTime) {
                stats.bestTime = gameTime;
            }
            
            if (!damageTaken) {
                stats.noDamageClears++;
            }
            
            if (gameTime <= 180) {
                stats.fastClears++;
            }
            
            if (difficulty === 'hard') {
                stats.hardClears++;
            }
            
            saveScore(gameTime, difficulty);
            saveStats();
            
            const newAchievements = checkAchievements();
            
            if (newAchievements.length > 0) {
                const achievementDiv = document.getElementById('newAchievements');
                achievementDiv.innerHTML = '<h3 style="color: #4ecca3;">üéâ Êñ∞„Åó„ÅÑÂÆüÁ∏æËß£Èô§ÔºÅ</h3>';
                newAchievements.forEach(ach => {
                    achievementDiv.innerHTML += `<p>${ach.icon} ${ach.name}</p>`;
                });
            }
            
            const settings = difficultySettings[difficulty];
            document.getElementById('clearMessage').textContent = 
                `Èõ£ÊòìÂ∫¶: ${settings.label}„ÅßËÑ±Âá∫ÊàêÂäüÔºÅ`;
            
            document.getElementById('clearScreen').classList.remove('hidden');
        }
        
        function gameLoop() {
            if (gameState === 'playing') {
                updatePlayer();
                teachers.forEach(teacher => updateTeacher(teacher));
                updateParticles();
                updateVignette();
                draw();
                updateUI();
                requestAnimationFrame(gameLoop);
            }
        }
        
        loadStats();
        loadHighScores();
    </script>
</body>
</html>